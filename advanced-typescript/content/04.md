#### Function overloading

Polymorphism for functions ðŸ¤”


<!-- Section 1 -->
##### What is it?

It is a for a function to have more than one signature. This allows for different behaviour and type-safe return types depending on the provided arguments.


<!-- Section 2 -->
##### What does it look like?

JavaScript (and therefore TypeScript) does not support proper function overloading as can be seen in other languages such as C# and Java. We can instead use multiple declarations, but only one implementation, to achieve the same effect.


<!-- Section 3 -->
##### The classic approach

The following implementation will simply return a union of all possible return types, or even `any` in more complex cases.

```typescript [1-7|9-11]
function reverse<T>(stringOrArray: string | Array<T>): string | Array<T> {
  if (typeof stringOrArray === "string") {
    return stringOrArray.split("").reverse().join("");
  }

  return stringOrArray.slice().reverse();
}

// Both are inferred as string | Array<string>
const shouldBeString = reverse("Yanick"); 
const shouldBeArray = reverse(["Y", "a", "n", "i", "c", "k"]);
```


<!-- Section 4 -->
##### The type-safe approach

The following implementation is vastly superior as TypeScript can infer the return type based on the arguments. We could also add separate JSDoc comments per definition.

```typescript [1-2|3-9|11-15]
function reverse(stringOrArray: string): string;
function reverse<T>(stringOrArray: Array<T>): Array<T>;
function reverse(stringOrArray: any): any {
  if (typeof stringOrArray === "string") {
    return stringOrArray.split("").reverse().join("");
  }

  return stringOrArray.slice().reverse();
}

// Inferred as string
const shouldBeString = reverse("Yanick");

// Inferred as Array<string>
const shouldBeArray = reverse(["Y", "a", "n", "i", "c", "k"]);
```